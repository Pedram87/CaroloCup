/*
 * nnRoadAngleCalc.c
 *
 * Code generation for function 'nnRoadAngleCalc'
 *
 * C source code generated on: Tue Jan 28 02:26:12 2014
 *
 */

/* Include files */
#include "rt_nonfinite.h"
#include "nnRoadAngleCalc.h"
#include "nnRoadSizeCalc.h"
#include "bsxfun.h"

/* Function Definitions */
void nnRoadAngleCalc(const double x1[3], double b_y1[3])
{
  double xp1[9];
  static const double settings_xoffset[3] = { 77.1957, 1.0, 20.0 };

  double b_xp1[9];
  static const double settings_gain[3] = { 0.0216217384958838,
    0.00397614314115308, 0.00925925925925926 };

  double c_xp1[9];
  double b[81];
  int ib;
  int jtilecol;
  int ia;
  int k;
  static const double a[27] = { -1.2302262573074245, -7.5848451435193329,
    8.043640345620938, -16.209581262990039, -3.364925068131789,
    -6.4944467907068573, -6.6682662951017715, -9.17078457971264,
    0.11809604294776438, 0.89615957776263833, -2.536005553366429,
    -0.83887245539021826, 2.0707997527460997, -0.93998973867431057,
    -6.2311559403405976, -1.5554616638430239, -2.4401551506491139,
    -3.6241363166847713, -3.3167771003109721, -7.5930745898988565,
    -8.7134370947041422, 1.8162143233439585, 1.3204899932149676,
    -3.2975106841309065, -2.6342462879641442, 1.8838768476219407,
    0.66413286264184024 };

  double b_b[81];
  double d0;
  static const double b_a[81] = { 10.019223175740025, -0.11709783709548983,
    5.4188239501696893, 14.663714635649152, -2.63091596792662,
    -12.020044781793521, 1.4221770795044388, 2.7848292212777266,
    1.950868687633418, 0.961740066994337, -4.108800773511434, 5.5593211194291916,
    -1.8971630237268162, 6.055159621007145, -14.515541416488265,
    8.4934978761610971, 3.116663703368908, -16.156438398435924,
    1.2918989401686443, 13.013587801033607, -6.8930256982986533,
    -0.048897379358372239, -34.02408408618475, -3.1978432825827752,
    -0.20486667175960338, -0.850825325579413, 3.0381628732968511,
    -2.6858760481913828, -6.7013779729545346, 0.64206737095692945,
    -9.7277064373892479, 0.85904098427869324, 4.0283869125465825,
    1.0731999338532263, -12.109399770008972, 1.1820168474520363,
    2.6111219023399208, 6.9079874541998851, 0.43439728580410969,
    5.3072988338988685, 2.6055552468539163, 0.2325251140211714,
    3.1454200277748594, -6.2246942475211977, -17.461422853618586,
    6.045324153295403, 14.431639774668168, -7.0407467112494979,
    2.2867591298448153, -21.180500840987595, 1.2022072727921185,
    -3.1243252663590368, 5.024188528983661, 2.0637953542675365,
    14.801615635794246, -1.2798619965442231, -4.3875519559659919,
    -15.2294418509664, -6.7387397027539082, 6.9151180742163838,
    -5.1027236644149845, 8.9207877173611383, 6.1347879037868127,
    5.4891205765368785, -3.6796646611562402, 0.23316916922279904,
    1.023907187987698, -0.50001250028651778, 11.166179821224349,
    -0.42451704458161016, -1.3035931636744533, 20.246127822019037,
    -2.3908835205382459, 13.615736922367658, 4.314366753239697,
    2.5297608437216494, -11.765123837585614, -6.5749434819439863,
    -3.6241117235682574, 0.93297756445772684, 1.09699801787599 };

  double x[81];
  double c_y1[3];
  static const double c_a[27] = { 0.075571700334858716, -1.7122438297437583,
    2.1089371660295555, 0.26753294387661225, 2.9566318371050944,
    0.10337761061773046, 1.549463565332871, 0.107843646480997,
    -0.78453332348556015, 1.1353999741150558, 1.1072104793147233,
    -0.9900753732551274, 7.4699387210589716, 2.634109965022819,
    -0.056898754824958805, -2.0470574169162465, 3.4355802673518117,
    0.163189601220638, -0.96633323258333514, 0.38798482484983593,
    0.14261451101074135, -3.6878221467785552, -0.17773251720693234,
    -3.2917861903989194, -2.4423579494094687, -4.2260788943667347,
    0.79905060693328778 };

  /* MYNEURALNETWORKFUNCTION neural network simulation function. */
  /*  */
  /*  Generated by Neural Network Toolbox function genFunction, 28-Jan-2014 00:45:46. */
  /*   */
  /*  [y1] = myNeuralNetworkFunction(x1) takes these arguments: */
  /*    x = 3xQ matrix, input #1 */
  /*  and returns: */
  /*    y = 1xQ matrix, output #1 */
  /*  where Q is the number of samples. */
  /*  ===== NEURAL NETWORK CONSTANTS ===== */
  /*  Input 1 */
  /*  Layer 1 */
  /*  Layer 2 */
  /*  Output 1 */
  /*  ===== SIMULATION ======== */
  /*  Dimensions */
  /*  samples */
  /*  Input 1 */
  /*  ===== MODULE FUNCTIONS ======== */
  /*  Map Minimum and Maximum Input Processing Function */
  bsxfun(x1, settings_xoffset, xp1);
  memcpy(&b_xp1[0], &xp1[0], 9U * sizeof(double));
  b_bsxfun(b_xp1, settings_gain, xp1);
  memcpy(&c_xp1[0], &xp1[0], 9U * sizeof(double));
  c_bsxfun(c_xp1, -1.0, xp1);

  /*  Layer 1 */
  ib = 0;
  for (jtilecol = 0; jtilecol < 3; jtilecol++) {
    ia = 0;
    for (k = 0; k < 27; k++) {
      b[ib] = a[ia];
      ia++;
      ib++;
    }
  }

  /*  Sigmoid Symmetric Transfer Function */
  for (ib = 0; ib < 27; ib++) {
    for (jtilecol = 0; jtilecol < 3; jtilecol++) {
      d0 = 0.0;
      for (k = 0; k < 3; k++) {
        d0 += b_a[ib + 27 * k] * xp1[k + 3 * jtilecol];
      }

      b_b[ib + 27 * jtilecol] = b[ib + 27 * jtilecol] + d0;
    }
  }

  for (ib = 0; ib < 3; ib++) {
    for (jtilecol = 0; jtilecol < 27; jtilecol++) {
      x[jtilecol + 27 * ib] = -2.0 * b_b[jtilecol + 27 * ib];
    }
  }

  for (k = 0; k < 81; k++) {
    x[k] = exp(x[k]);
  }

  /*  Layer 2 */
  /*  Output 1 */
  /*  Map Minimum and Maximum Output Reverse-Processing Function */
  for (ib = 0; ib < 3; ib++) {
    for (jtilecol = 0; jtilecol < 27; jtilecol++) {
      b[jtilecol + 27 * ib] = 2.0 / (1.0 + x[jtilecol + 27 * ib]) - 1.0;
    }
  }

  for (ib = 0; ib < 3; ib++) {
    d0 = 0.0;
    for (jtilecol = 0; jtilecol < 27; jtilecol++) {
      d0 += c_a[jtilecol] * b[jtilecol + 27 * ib];
    }

    c_y1[ib] = -1.5458785673027935 + d0;
  }

  d_bsxfun(c_y1, -1.0, b_y1);
  for (ib = 0; ib < 3; ib++) {
    c_y1[ib] = b_y1[ib];
  }

  e_bsxfun(c_y1, 0.0214832693668988, b_y1);
  for (ib = 0; ib < 3; ib++) {
    c_y1[ib] = b_y1[ib];
  }

  f_bsxfun(c_y1, 50.1213, b_y1);
}

/* End of code generation (nnRoadAngleCalc.c) */
