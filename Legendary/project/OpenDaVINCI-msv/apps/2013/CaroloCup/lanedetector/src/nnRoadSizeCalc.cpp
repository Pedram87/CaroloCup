/*
 * nnRoadSizeCalc.c
 *
 * Code generation for function 'nnRoadSizeCalc'
 *
 * C source code generated on: Tue Jan 28 02:26:12 2014
 *
 */

/* Include files */
#include "rt_nonfinite.h"
#include "nnRoadAngleCalc.h"
#include "nnRoadSizeCalc.h"
#include "bsxfun.h"

/* Function Definitions */
void nnRoadSizeCalc(const double x1[3], double b_y1[3])
{
  double xp1[9];
  static const double settings_xoffset[3] = { 77.1957, 1.0, 20.0 };

  double b_xp1[9];
  static const double settings_gain[3] = { 0.0216217384958838,
    0.00397614314115308, 0.00925925925925926 };

  double c_xp1[9];
  double b[81];
  int ib;
  int jtilecol;
  int ia;
  int k;
  static const double a[27] = { 7.6431612572200978, -5.031997787628419,
    -3.2285445212465707, 6.6599585086071347, 2.7105689744215669,
    3.502020061102106, -3.632700064230713, -3.010481285288007,
    -0.57404018720312044, -1.4330045498859794, -0.57500597138865972,
    -0.64621044311504527, 2.4094876456255871, 1.89079506065875,
    0.62574545969677531, 2.2576892214133273, 4.8068074797622673,
    -3.62508144353152, -0.099333719028133, 2.4984998753587253,
    -3.5155184329755178, 4.3024917558860505, 3.3650708056917114,
    1.1187079370110522, 3.4676903764881146, 4.8531685930382347,
    4.3576280844017763 };

  double b_b[81];
  double d1;
  static const double b_a[81] = { -10.870476193153142, -2.4213957469476126,
    2.0890254541660065, 2.0879000357759452, -2.6345968037561973,
    -3.6801977950435814, 1.0588814148889205, 4.9264149939346451,
    5.9639937099052593, 2.0534973268403016, 6.5580426463066148,
    2.943113952380545, -2.795140144434519, 0.32011010379017507,
    -6.3634375372852059, 2.5407300874808811, 3.5634638207865654,
    -2.6611349615864968, -1.9054382594363644, 2.8749904458252478,
    -2.4650983243463744, 3.2272776394781943, -0.21932441410973702,
    -1.1853918131800636, 4.592181056391242, 2.6953855653327361,
    0.65447414854323893, 1.6013231897094926, 3.1678029367287737,
    3.089739552459513, 5.4167443530939092, -1.6435507738361763,
    -2.3519464158361481, 5.84477357092952, 1.4005925654470992,
    -0.038507776725633984, -0.79928046550482612, 0.42265937381234,
    0.47677832115094632, -1.167756040014323, 1.249431361338299,
    0.45121281972028437, -2.5633796090175132, 7.6030310818605491,
    -5.2824179572488408, 0.695727200597606, -8.8722824200373953,
    2.3071691368664053, 6.599559064510391, -7.3860824717964277,
    0.75716004733503506, -3.8331685912328828, 3.3373408411200836,
    3.7763992494688363, 7.131542850483477, -5.7897612050622405,
    3.466158837326117, 0.4913636058140341, -4.3422831829404034,
    -2.1590401927637584, -2.2612443428576556, 0.11806344492301497,
    2.4574160843679147, -3.2340639602449954, 3.2554921546328464,
    -1.255184203935102, -3.2572638197905603, -1.5869812204376172,
    -2.0914773965191653, -3.15286221775322, 1.2898996060178261,
    -0.20754035649437796, 3.7081653063982567, 2.0861543660921029,
    -4.1753987537708115, 0.8042572684891186, -0.21738196856459857,
    2.2608980079210954, -4.7624839906995495, 0.92163511736729842,
    6.7800409318042005 };

  double x[81];
  double c_y1[3];
  static const double c_a[27] = { 0.33332402690754509, 3.882176258615202,
    2.6787241139368847, 2.4394720674924284, -1.5653004125238654,
    4.1163311822645827, -2.493502119998857, 1.5116309481631689,
    -3.4249281209065368, -3.7311617708507625, 1.5974280327246948,
    0.89074145705613417, 2.1473811403565488, -0.79583189220731887,
    -1.4879186480248447, 2.2826118372500273, 2.9190427266022612,
    -3.0917909538408468, 0.921105414464465, -0.696875652045077,
    -3.5690708108886295, -5.5728448342165811, -2.0835258548035722,
    -5.23353933461173, -1.5479669310815438, -2.4780085712116495,
    0.24097527817454539 };

  /* MYNEURALNETWORKFUNCTION neural network simulation function. */
  /*  */
  /*  Generated by Neural Network Toolbox function genFunction, 28-Jan-2014 01:09:40. */
  /*   */
  /*  [y1] = myNeuralNetworkFunction(x1) takes these arguments: */
  /*    x = 3xQ matrix, input #1 */
  /*  and returns: */
  /*    y = 1xQ matrix, output #1 */
  /*  where Q is the number of samples. */
  /*  ===== NEURAL NETWORK CONSTANTS ===== */
  /*  Input 1 */
  /*  Layer 1 */
  /*  Layer 2 */
  /*  Output 1 */
  /*  ===== SIMULATION ======== */
  /*  Dimensions */
  /*  samples */
  /*  Input 1 */
  /*  ===== MODULE FUNCTIONS ======== */
  /*  Map Minimum and Maximum Input Processing Function */
  bsxfun(x1, settings_xoffset, xp1);
  memcpy(&b_xp1[0], &xp1[0], 9U * sizeof(double));
  b_bsxfun(b_xp1, settings_gain, xp1);
  memcpy(&c_xp1[0], &xp1[0], 9U * sizeof(double));
  c_bsxfun(c_xp1, -1.0, xp1);

  /*  Layer 1 */
  ib = 0;
  for (jtilecol = 0; jtilecol < 3; jtilecol++) {
    ia = 0;
    for (k = 0; k < 27; k++) {
      b[ib] = a[ia];
      ia++;
      ib++;
    }
  }

  /*  Sigmoid Symmetric Transfer Function */
  for (ib = 0; ib < 27; ib++) {
    for (jtilecol = 0; jtilecol < 3; jtilecol++) {
      d1 = 0.0;
      for (k = 0; k < 3; k++) {
        d1 += b_a[ib + 27 * k] * xp1[k + 3 * jtilecol];
      }

      b_b[ib + 27 * jtilecol] = b[ib + 27 * jtilecol] + d1;
    }
  }

  for (ib = 0; ib < 3; ib++) {
    for (jtilecol = 0; jtilecol < 27; jtilecol++) {
      x[jtilecol + 27 * ib] = -2.0 * b_b[jtilecol + 27 * ib];
    }
  }

  for (k = 0; k < 81; k++) {
    x[k] = exp(x[k]);
  }

  /*  Layer 2 */
  /*  Output 1 */
  /*  Map Minimum and Maximum Output Reverse-Processing Function */
  for (ib = 0; ib < 3; ib++) {
    for (jtilecol = 0; jtilecol < 27; jtilecol++) {
      b[jtilecol + 27 * ib] = 2.0 / (1.0 + x[jtilecol + 27 * ib]) - 1.0;
    }
  }

  for (ib = 0; ib < 3; ib++) {
    d1 = 0.0;
    for (jtilecol = 0; jtilecol < 27; jtilecol++) {
      d1 += c_a[jtilecol] * b[jtilecol + 27 * ib];
    }

    c_y1[ib] = 0.029774367902390998 + d1;
  }

  d_bsxfun(c_y1, -1.0, b_y1);
  for (ib = 0; ib < 3; ib++) {
    c_y1[ib] = b_y1[ib];
  }

  e_bsxfun(c_y1, 0.00224971878515186, b_y1);
  for (ib = 0; ib < 3; ib++) {
    c_y1[ib] = b_y1[ib];
  }

  f_bsxfun(c_y1, 419.0, b_y1);
}

/* End of code generation (nnRoadSizeCalc.c) */
